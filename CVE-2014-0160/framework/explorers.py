import angr
from helpers import flatten
import detectors

class Explorer():
    def __init__(self, project: angr.Project, state: angr.sim_state.SimState) -> None:
        self.project = project
        self.sim = project.factory.simgr(state)
        self.buggy_states = []
        self.hooks_addrs = [] #In the future we may want to store old hooks?
    
    def stats(self): # Here we can collect all the statistics we want so we can perform comparisons
        states = [x for x in self.sim.stashes.values()]
        bblocks = set()
        for st in flatten(states):
            bblocks.update(st.history.bbl_addrs)
        return {"Unique blocks explored": len(bblocks), "Number of buggy states": len(set(self.buggy_states))}   
    
    def go(self, num_buggy):
        print("this does nothing use one of the subclasses")

    def clean_hooks(self): #So we can detach ourselves
        for hook in self.hooks_addrs:
            self.project.unhook(hook)

class NaiveExplorer(Explorer):
    def go(self, num_buggy): 
        while True:
            try:
                self.sim.step()
            except detectors.BugFoundError as e:
                self.buggy_states.append(e.state)
                continue
        
class EUPExplorer(Explorer):
    
    @staticmethod
    def end_unit_hook(state: angr.sim_state.SimState):
        # Is this the correct way to do it?
        # After an execution unit ends, I just force it to call exit() causing it to go into the deadended stash. 
        # This will keep the total number of states down, but what do we lose?

        angr.SIM_PRECEDURES["libc"]["exit"].execute(state)

    #begin_addr and end_addr are the boundaries of our Execution unit
    def go(self, num_buggy, begin_addr, end_addr):
        new_state = self.sim.explore(find=begin_addr).found[0]

        self.project.hook(end_addr, self.__class__.end_unit_hook)
        self.hooks_addrs.append(end_addr)

        self.sim = self.project.factory.simgr(new_state)
        
        while True:
            try:
                self.sim.step()
            except detectors.BugFoundError as e:
                self.buggy_states.append(e.state)
                continue


