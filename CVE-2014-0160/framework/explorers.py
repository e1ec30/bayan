import angr
from helpers import flatten
import detectors
from collections import defaultdict

class Explorer():
    def __init__(self, project: angr.Project, state: angr.sim_state.SimState) -> None:
        self.project = project
        self.sim = project.factory.simgr(state)
        self.buggy_states = []
        self.hooks_addrs = [] #In the future we may want to store old hooks?
    
    def stats(self): # Here we can collect all the statistics we want so we can perform comparisons
        states = [x for x in self.sim.stashes.values()]
        bblocks = set()
        for st in flatten(states):
            bblocks.update(st.history.bbl_addrs)
        return {"Unique blocks explored": len(bblocks), "Number of buggy states": len(set(self.buggy_states))}   
    
    def go(self, num_buggy):
        print("Cannot Go")

class NaiveExplorer(Explorer):
    def go(self, num_bugs): 
        while len(self.buggy_states) < num_bugs:
            try:
                self.sim.step()
            except detectors.BugFoundError as e:
                self.buggy_states.append(e.state)
                continue
    
    def __init__(self, project: angr.Project, state: angr.sim_state.SimState) -> None:
        super().__init__(project, state)
        
class EUPExplorer(Explorer):
    
    @staticmethod
    def option_a_hook(state: angr.sim_state.SimState):

        for x in state.solver.constraints:
            for y in x.recursive_children_asts:
                if y.symbolic and len(list(y.children_asts())) == 0:
                    state.solver.add(y == state.solver.eval(y))
                    state.solver.simplify()   

    @staticmethod
    def option_b_hook(state: angr.sim_state.SimState):
        state.solver.constraints.clear()

    @staticmethod
    def no_hook(state):
        pass

       
    def go(self, loop_head, num_bugs, hook_type="a"):

        #We'll have to find the loophead ourselves eventually
        self.project.hook(loop_head, self.hook_types[hook_type])
        while len(self.buggy_states) < num_bugs:
            try:
                self.sim.step()
            except detectors.BugFoundError as e:
                self.buggy_states.append(e.state)
                continue

    def __init__(self, project: angr.Project, state: angr.sim_state.SimState) -> None:
        super().__init__(project, state)
        self.hook_types = defaultdict(lambda: self.__class__.no_hook,a=self.__class__.option_a_hook, b=self.__class__.option_b_hook)
