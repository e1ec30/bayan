import signal
import sys
import time
import logging
import argparse
from itertools import chain
import angr
import detectors
import explorers

l = logging.getLogger()
l.setLevel(logging.ERROR)

parser = argparse.ArgumentParser("main.py")
parser.add_argument("target", type=str, help="target", default="./toybox")
parser.add_argument("s", type=int, help="number of seconds to run the explorers", default=20)

args = parser.parse_args()

timeout = args.s

target = args.s

class TimeoutError(Exception): # So we can  limit execution time
    pass

def handle_timeout(signum, frame):
    raise TimeoutError("Timeout")

def run_with_timeout(func, timeout, *args, **kwargs):
    signal.signal(signal.SIGALRM, handle_timeout)

    begin_time = time.time()

    signal.alarm(timeout)
    try:
        result = func(*args, **kwargs)

    except TimeoutError:
        print(f"Error: {func} timed out")
        result = None

    finally:
        end_time = time.time()
        total_time = int(end_time - begin_time)
        signal.alarm(0)

    return total_time, result

if len(sys.argv) > 1:
    target = sys.argv[1]

proj = angr.Project(target)
entry_state = proj.factory.entry_state(args=[target, "4040"])


def main():
    heartdetect = detectors.HearbleedDetector()
    heartdetect.attach(proj)

    begin = 0x40159d # Beginning of our execution unit
    end = 0x40177b # end of our execution unit
    
    naive = explorers.NaiveExplorer(proj, entry_state)
    eup   = explorers.EUPExplorer(proj, entry_state)

    naive_time, _  = run_with_timeout(naive.go, timeout, 1)
    naive.clean_hooks()

    eup_time, _    = run_with_timeout(eup.go, timeout, 1, begin, end)
    eup.clean_hooks()

    print(f"EUP ran for: {eup_time} seconds  and gave stats: {eup.stats()}")    
    print(f"Naive ran for: {naive_time} seconds and gave stats: {naive.stats()}")

if __name__ == "__main__":
    main()

# sim = proj.factory.simgr(entry_state)

# buggy_states = []

# while len(buggy_states) < 1:
#     try:
#         sim.step()
#     except detectors.BugFoundError as e:
#         print(e.state)

        
